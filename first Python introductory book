
# <editor-fold desc="变量赋值并打印结果">
'''变量赋值并打印结果'''
# a=1
# print(a)
# </editor-fold>
# <editor-fold desc="创建文件并写入内容n">
'''创建文件并写入内容'''
# file = open('C:/Users/Administrator/Desktop/test.txt','w')
# file.write('hello world!')
# </editor-fold>
# <editor-fold desc="打印字符串">
'''打印字符串'''
# what_he_does = ' plays '
# his_instrument = 'guitar'
# his_name = 'Robert Johnson'
# artist_intro = his_name + what_he_does + his_instrument
#
# print(artist_intro)
# </editor-fold>
# <editor-fold desc="不同字符类型运算">
'''不同字符类型运算'''
# num = 1
# string = 1
# num2 = int(string)
#
# print(num + num2)
# </editor-fold>
# <editor-fold desc="字符串重复">
'''字符串重复'''
# words = 'words' * 3
# print(words)
# </editor-fold>
# <editor-fold desc="len">
'''len'''
# word = 'a looooong word'
# num = 12
# string = 'bang!'
# total = string * (len(word) - num)
# print(total)
# </editor-fold>
# <editor-fold desc="字符串位置">
'''字符串位置'''
# name = 'My name is Mike'
# print(name[0])
# print(name[-4])
# print(name[11:14])
# print(name[11:15])
# print(name[5:])
# print(name[:5])
# print(name[:-10])
# </editor-fold>
# <editor-fold desc="字符串索引">
'''字符串索引'''
# word = 'friends'
# find_the_evil_in_your_friends = word[0] + word[2:4] + \
#                                 word[-3:-1]
# print(find_the_evil_in_your_friends)
# </editor-fold>
# <editor-fold desc="字符串索引_项目实例">
'''字符串索引_项目实例'''
# url = 'http://ww1.site.cn/14d2e8ejw1exjogbxdxhj20ci0kuwex.jpg'
# file_name = url[-10:]
# print(file_name)
# </editor-fold>
# <editor-fold desc="替换-replace">
'''替换-replace'''
# phone_number = '1386-666-0006'
# hiding_number = phone_number.replace(phone_number[:9],'*'*9)
# print(hiding_number)
# </editor-fold>
# <editor-fold desc="电话号码搜索-find">
'''电话号码搜索-find'''
# search = '168'
# num_a = '1386-168-0006'
# num_b = '1681-222-0006'
#
# print(search + ' is at ' + str(num_a.find(search)) + ' to ' +
#       str(num_a.find(search) + len(search) )+ ' of num_a')
# print(search + ' is at ' + str(num_b.find(search)) + ' to ' +
#       str(num_b.find(search) + len(search)) + ' of num_b')
# </editor-fold>
# <editor-fold desc="字符串格式化符-format">
'''字符串格式化符-format'''
# print('{} a word she can get what she {} for.'.format('with','came'))
# print('{preposition} a word she can get what she {verb} for.'
#       .format(preposition = 'with',verb = 'came'))
# print('{0} a word she can get what she {1} for.'.format('with','came'))
# </editor-fold>
# <editor-fold desc="字符串格式化符-format-实例">
'''字符串格式化符-format-实例'''
# city = input("write down the name of city:")
# url = "http://apistore.baidu.com/microservice/weather?citypinyin={}".format(city)
# </editor-fold>
# <editor-fold desc="定义函数">
'''定义函数'''
# def fahrenheit_converter(C):
#     fahrenheit = C * 9/5 + 32
#     return str(fahrenheit) + '°F'
# C2F = fahrenheit_converter(35)
# print(C2F)
# </editor-fold>
# <editor-fold desc="定义函数-梯形面积">
'''定义函数-梯形面积'''
# def Trapezoidal_area(a,b,h):
#     S = 1/2*(a+b)*h
#     return S
# T = Trapezoidal_area(3,4,5)
# print(T)
# </editor-fold>
# <editor-fold desc="定义函数-圆形面积">
'''定义函数-圆形面积'''
# def circle(r):
#     S = 3.1415926*r*r
#     return int(S)
# C = circle(3)
# print(C)
# </editor-fold>
# <editor-fold desc="定义函数-温度转换器">
'''定义函数-温度转换器'''
# def fahrenheit_converter(C):
#     fahrenheit = C *9/5 + 32
#     print(str(fahrenheit) + '°F')
#
# C2F = fahrenheit_converter(35)
# print(C2F)
# </editor-fold>
# <editor-fold desc="定义函数-重量单位g/kg换算">
'''定义函数-重量单位g/kg换算'''
# def weight_converter(g):
#     kg = 1/1000*g
#     return kg
# weight = weight_converter(500)
# print(weight)
# </editor-fold>
# <editor-fold desc="定义函数-重量单位g/kg换算-标准答案">
'''定义函数-重量单位g/kg换算-标准答案'''
# def g2kg(g):
#     return str(g/1000) + 'kg'
#
# print(g2kg(2000))
# </editor-fold>
# <editor-fold desc="定义函数-直角三角形斜边长">
'''定义函数-直角三角形斜边长'''
# def Right_triangle(a,b):
#     c = (a**2+b**2)**(1/2)
#     return str(c)
# Hypotenuse_length = Right_triangle(3,4)
# print("The right triangle third side's length is " + Hypotenuse_length)
# </editor-fold>
# <editor-fold desc="定义函数-直角三角形斜边长-标准答案">
'''定义函数-直角三角形斜边长-标准答案'''
# def Pythagorean_theorem(a,b):
#     return 'The right triangle third side\'s length is {}'.format((a**2+b**2)**(1/2))
# print(Pythagorean_theorem(3,4))
# </editor-fold>
# <editor-fold desc="参数传递-位置">
'''参数传递-位置'''
# def trapezoid_area(base_up,base_down,height):
#     return 1/2 * (base_up + base_down) * height
# area = trapezoid_area(1,2,3)
# area = trapezoid_area(base_up=1,base_down=2,height=3)

# area = trapezoid_area(height=3,base_down=2,base_up=1)    # right
# area = trapezoid_area(height=3,base_down=2,1)            # wrong
# area = trapezoid_area(base_up=1,base_down=2,3)           # wrong
# area = trapezoid_area(1,2,height=3)                        # right
# print(area)
# </editor-fold>
# <editor-fold desc="参数传递-位置和关键词">
'''参数传递-位置和关键词'''
# def trapezoid_area(base_up,base_down,height):
#     return 1/2 * (base_up + base_down) * height
# base_up = 1
# base_down = 2
# height = 3
# print(trapezoid_area(height,base_down,base_up))
# print(trapezoid_area(height=3,base_down=2,base_up=1))
# 这两种方式：上面的是位置参数传入；下面的是关键词参数传入。注意区别！
# </editor-fold>
# <editor-fold desc="每一段换行-sep">
'''每一段换行-sep'''
# # print('  *',' * *','* * *','  |  ')
# print('  *',' * *','* * *','  |  ',sep = '\n')
# </editor-fold>
# <editor-fold desc="参数默认值">
'''参数默认值'''
# def trapezoid_area(base_up,base_down,height=3):
#     return 1/2 * (base_up + base_down) * height
# print(trapezoid_area(1,2))
# print(trapezoid_area(1,2,height=15))
# </editor-fold>
# <editor-fold desc="创建文件并过滤关键词">
'''创建文件并过滤关键词'''
# def text_create(name,msg):
#     desktop_path = 'C:/Users/Administrator/Desktop/'
#     full_path = desktop_path + name + '.txt'
#     file = open(full_path,'w')
#     file.write(msg)
#     file.close()
#     print('Done')
# text_create('hello','hello world!')     #调用函数
#
# def text_filter(word,cencored_word='lame',changed_word='Awesome'):
#     return word.replace(cencored_word,changed_word)     #替换
# print(text_filter('Python is lame!'))
#
# def text_censored_create(name,msg):
#     clean_msg = text_filter(msg)
#     text_create(name,clean_msg)
# text_censored_create('Try','lame!lame!lame!')
# </editor-fold>
# <editor-fold desc="输入登陆密码1">
'''输入登陆密码1'''
# def account_login():
#     password =  input('Password:')
#     if password == '12345':
#         print('Login success!')
#     else:
#         print('Wrong password or invalid input!')
#         account_login()
# account_login()
# </editor-fold>
# <editor-fold desc="输入登陆密码2">
'''输入登陆密码2'''
# def account_login():
#     password = input('Password:')
#     password_correct = password == '12345'
#     if password_correct:
#         print('Login success!')
#     else:
#         print('Wrong password or invalid input!')
#         account_login()
# account_login()
# </editor-fold>
# <editor-fold desc="输入及更新登陆密码">
'''输入及更新登陆密码'''
# password_list = ['*#*#','12345']
# def account_login():
#     password = input('Password:')
#     password_correct = password == password_list[-1]
#     password_reset = password == password_list[0]
#     if password_correct:
#         print('Loggin success!')
#     elif password_reset:
#         new_password = input('Enter a new password:')
#         password_list.append(new_password)
#         print('Your password has changed successfully!')
#         account_login()
#     else:
#         print('Wrong password or invalid input!')
#         account_login()
# account_login()
# </editor-fold>
# <editor-fold desc="for循环-基础">
'''for循环-基础'''
# for every_letter in 'Hello world':
#     print(every_letter)
# </editor-fold>
# <editor-fold desc="for循环-range">
'''for循环-range'''
# for num in range(1,11):
#     print(str(num) + ' + 1 = ',num + 1)
# </editor-fold>
# <editor-fold desc="for循环-elif_else">
'''for循环-elif_else'''
# songslist = ['Holy Diver','Thunderstruck','Rebel Rebel']
# for song in songslist:
#     if song == 'Holy Diver':
#         print(song,' - Dio')
#     elif song == 'Thunderstruck':
#         print(song,' - AC/DC')
#     else:
#         print(song,' - David Bowie')
# </editor-fold>
# <editor-fold desc="for循环-嵌套for循环1">
'''for循环-嵌套for循环1'''
# for x in range(1,10):
#     for y in range(1,10):
#         print(str(x),' * ',str(y),' = ',x*y)
# </editor-fold>
# <editor-fold desc="for循环-嵌套for循环2">
'''for循环-嵌套for循环2'''
# for i in range(1,10):
#     for j in range(1,10):
#         print('{} X {} = {}'.format(i,j,i*j))
# </editor-fold>
# <editor-fold desc="while循环-基础">
'''while循环-基础'''
# while 1 < 3:
#     print('1 is smaller than 3')
# </editor-fold>
# <editor-fold desc="while循环-break">
'''while循环-break'''
# count = 0
# while True:
#     print('Repeat this line !')
#     count = count + 1
#     if count == 5:
#         break
# </editor-fold>
# <editor-fold desc="while循环-嵌套if语句">
'''while循环-嵌套if语句'''
# password_list = ['*#*#','12345']
# def account_login():
#     tries = 3
#     while tries > 0:
#         password = input('Password:')
#         password_correct = password == password_list[-1]
#         password_reset = password == password_list[0]
#         if password_correct:
#             print('Login success!')
#
#         elif password_reset:
#             new_password = input('Enter a new password :')
#             password_list.append(new_password)
#             print('Passowrd has changed successfully!')
#             account_login()
#         else:
#             print('Wrong password or invalid input!')
#             tries = tries - 1
#             print(tries,'times left')
#
#     else:
#         print('Your account has been suspended')
# account_login()
# </editor-fold>
# <editor-fold desc="创建10个文件">
'''创建10个文件'''
# file = open('C:/Users/Administrator/Desktop/text.txt','w')
# file.write('test')

# def text_create(name,msg):
#     desktop_path = 'C:/Users/Administrator/Desktop/'
#     full_path = desktop_path + name + '.txt'
#     file = open(full_path,'w')
#     file.write(msg)
#     file.close()
#     print('Done')
# text_create('hello','hello world!')     #调用函数
#
#
# def text_filter(word,cencored_word='lame',changed_word='Awesome'):
#     return word.replace(cencored_word,changed_word)     #替换
# print(text_filter('Python is lame!'))
#
# def text_censored_create(name,msg):
#     clean_msg = text_filter(msg)
#     text_create(name,clean_msg)
# text_censored_create('Try','lame!lame!lame!')

'''
def text_create():
    desktop_path = 'C:/Users/Administrator/Desktop/test/'

    for name in range(1,11):
        full_path = desktop_path + str(name) + '.txt'
        full_path = open(full_path,'w')

        full_path.close()
text_create()

def text_creation():
    path = 'C:/Users/Administrator/Desktop/test/'
    for name in range(1,11):
        with open(path + str(name) + '.txt','w') as text:
            text.write(str(name))
            text.close()
            print('Done')
text_creation()
'''
# </editor-fold>
# <editor-fold desc="设计复利计算函数">
'''
def invest(amount,rate,time):
    calculation = input('principal_amount:')
    for y in range(1,time+1):
        amount = amount * (1 + rate)
        print('year {}: ${}'.format(y,amount))
invest(100,0.05,8)
'''
# </editor-fold>
# <editor-fold desc="设计复利计算函数-标准答案">
'''
def invest(amount,rate,time):
    print("principal amount:{}".format(amount))
    for t in range(1,time + 1):
        amount = amount * (1 + rate)
        print("year {}: ${}".format(t,amount))
invest(100,.05,8)
invest(2000,.025,5)
'''
# </editor-fold>
# <editor-fold desc="打印1-100的偶数">
'''
def even():
    for a in range(1,101):
        remainder = a % 2
        if remainder == 0:

            print(a)
even()
'''
# </editor-fold>
# <editor-fold desc="打印1-100的偶数-标准答案">
'''
def even_print():
    for i in range(1,101):
        if i % 2 == 0:
            print(i)
even_print()
'''
# </editor-fold>
# <editor-fold desc="列表求和-sum">
'''
a_list = [1,2,3]
print(sum(a_list))
'''
# </editor-fold>
# <editor-fold desc="导入库-random">
'''
import random

point1 = random.randrange(1,7)
point2 = random.randrange(1,7)
point3 = random.randrange(1,7)

print(point1,point2,point3)
'''
# </editor-fold>
# <editor-fold desc="摇骰子猜大小游戏">
'''
# 创建摇骰子函数
import random
def roll_dice(numbers=3,points=None):
    print('<<<<< ROLL THE DICE! >>>>>')
    if points is None:
        points = []
    while numbers > 0:
        point = random.randrange(1,7)
        points.append(point)
        numbers = numbers - 1
    return points
#将点数转化成大小
def roll_result(total):
    isBig = 11 <= total <=18
    isSmall = 3 <= total <=10
    if isBig:
        return 'Big'
    elif issmall:
        return 'Small'
# 用户猜大小
def start_game():
    print('<<<<< GAME STARTS! >>>>>')
    choices = ['Big','Small']
    your_choice = input('Big or Small :')
    if your_choice in choices:
        points = roll_dice()
        total = sum(points)
        youwin = your_choice == roll_result(total)
        if youwin:
            print('The points are',points,'You win !')
        else:
            print('The points are',points,'You lose !')
    else:
        print('Invalid Words')
        start_game()
start_game()
'''
# </editor-fold>
# <editor-fold desc="摇骰子猜大小下注">
'''
import random

def roll_dice(number = 3,points = None):
    print('<<<<<<< ROLL THE DICE! >>>>>>>')
    if points is None:
        points = []
    while number > 0:
        point = random.randrange(1,7)
        points.append(point)
        number = number - 1
    return points

def roll_result(total):
    isBig = 11 <= total <=18
    isSmall = 3<= total <=10
    if isBig:
        return 'Big'
    elif isSmall:
        return 'Small'

def start_game():
    your_money = 1000
    while your_money > 0:
        print('<<<<< GAME STARTS! >>>>>')
        choice = ['Big','Small']
        Your_choice = input('Big or Small :')
        if Your_choice in choice:
            your_bet = input('How much you wanna bet ? - ')
            points = roll_dice()
            total = sum(points)
            youwin = Your_choice == roll_result(total)
            if youwin:
                your_money = your_money + int(your_bet)
                print('The points is {} You Win'.format(points))
                print('You gained {},you have {} now'.format(your_bet,your_money))
            else:
                your_money = your_money - int(your_bet)
                print('The points is {} You Lose'.format(points))
                print('The lost {},you have {} now'.format(your_money,your_bet))
        else:
            print('Invailid Words')
    else:
        print('GAME OVER')
start_game()
'''
# </editor-fold>
# <editor-fold desc="验证手机号-练习">
'''
def mobile_number():

    while True:
        number = input('Enter Your number :')
        CN_mobile = [134,135,136,137,138,139,150,151,152,157,158,159,182,183,184,187,188,147,178,1705]
        CN_union = [130,131,132,155,156,185,186,145,176,1709]
        CN_telecom = [133,153,180,181,189,177,1700]
        first_three = int(number[0:3])
        first_four = int(number[0:4])

        if len(number) == 11:
            if first_three in CN_mobile or first_four in CN_mobile:
                print('Operator : China Mobile')
                print("We're sending verification code via text to your phone: ",number)
                break
            elif first_three in CN_union or first_four in CN_union:
                print('Operator : China union')
                print("We're sending verification code via text to your phone: ",number)
                break
            elif first_three in CN_telecom or first_four in CN_telecom:
                print('Operator : China telecom')
                print("We're sending verification code via text to your phone: ",number)
                break
            else:
                print('No such a operator')
        else:
            print('Invalid length,your number should be in 11 digits')
mobile_number()
'''
# </editor-fold>

# <editor-fold desc="数据结构-列表（list)">
# 数据结构-列表（list)
# 特征：
# 1.列表中的元素是可变的，可以在列表中添加、删除和修改元素。
# 2.列表中的每一个元素都对应着一个位置，输入位置可查询该位置所对应的值。
'''
Weekday = ['Monday','Tuesday','Wednesday','Thursday','Friday']
print(Weekday[0])
'''
# 3.列表可以装入Python中所有的对象。
'''
all_in_list = [
    1,                  # 整数
    1.0,                # 浮点数
    'a word',           # 字符串
    print(1),           # 函数
    True,               # 布尔值
    [1,2],              # 列表中套列表
    (1,2),              # 元组
    {'key':'value'}     # 字典
]
'''
# 列表的增删改查
# 插入
# 指定位置元素之前的位置
'''
fruit = ['pineapple','pear']
fruit.insert(1,'grape')
print(fruit)
# 括号中的数值表示位置范围
fruit[0:0] = ['orange']
print(fruit)
fruit[1:1] = ['banana']
print(fruit)
fruit[0:1] = ['apple'] #类似于fruit[0]='apple'
print(fruit)
'''
# extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。
'''
a = [1,2,3,4,5]
b = ['a','b']
a.extend(b)
print(a)
'''
# 删除
'''
fruit = ['pinapple','pear','grape']
fruit.remove('grape')
print(fruit)
# 替换修改
fruit[0] = 'Grapefruit'
print(fruit)
# 用del关键字删除
del fruit[0:2]
print(fruit)
'''
# 列表的索引-位置
'''
periodic_table = ['H','He','Li','Be','B','C','N','O','F','Ne']
print(periodic_table[0])
print(periodic_table[-2])
print(periodic_table[0:3])
print(periodic_table[-10:-7])
print(periodic_table[-10:])
print(periodic_table[0:9])
# 列表只接受用位置进行索引，不支持查看某个具体的值所在的位置：
print(periodic_table['H'])
'''
# list切片：语法：[start:stop:step]
'''
st = ['a','b','c','d','e','f','g']
print(st[2:6:2])
print(st[6:2:-2])
print(st[::1])
print(st[::-1])
print(st[-1])
'''
# </editor-fold>
# <editor-fold desc="数据结构-字典（Dictionary）">
# 数据结构-字典（Dictionary）
# 字典的特征：
# 1.字典中数据必须是以键值对的形式出现的；
# 2.逻辑上讲，键是不能重复的，而值可以重复；
# 3.字典中的键（key）是不可变的，也就是无法修改的；而值（value）是可变的，可修改的，可以是任何对象。
'''
NASDAQ_code = {
    'BIDU':'Baidu',
    'SINA':'Sina',
    'YOKU':'Youku'
}
print(NASDAQ_code)
'''
# 键与值（key:value）是一一对应的，不能脱离对方而存在：
'''
NASDAQ_code = {'BIDU':}
'''
# 可变（mutable）元素不能作为key：
'''
key_test = {[]:'a Test'}
print(key_test)
'''
# 键值不会有重复，相同的键值只能出现一次：
'''
a = {'key':123,'key':123}
print(a)
'''
# 字典的增删改查
'''
NASDAQ_code = {'BIDU':'Baidu','SINA':'Sina'}
NASDAQ_code['YOUKU'] = 'Youku'
print(NASDAQ_code)
# 字典中添加多个元素的方法-update()
NASDAQ_code.update({'FB':'Facebook','TSLA':'Tesla'})
print(NASDAQ_code)
# 删除字典中的元素-del:
del NASDAQ_code['FB']
print(NASDAQ_code)
# 索引字典的内容用方括号，括号中放入的是字典中的键。即通过键来索引值：
NASDAQ_code['TSLA']
# 字典不能够不切片，下面的写法应用在字典上是错误的：
chart[1:4]
'''
# </editor-fold>
# <editor-fold desc="数据结构-元组（Tuple）">
# 数据结构-元组（Tuple）
# 元组是不可修改的，但元组可以被查看索引
'''
letters = ('a','b','c','d','e','f','g')
letters[0]
'''
# </editor-fold>
# <editor-fold desc="数据结构-集合（Set）">
# 数据结构-集合（Set）
# 每一个集合中的元素是无序的、不重复的任意对象，
    # 可以通过集合去判断数据的从属关系
    # 还可以通过集合把数据结构中重复的元素减掉
# 集合不能被切片也不能被索引，可以做集合运算，可以被添加和删除：
'''
a_set = {1,2,3,4}
a_set.add(5)
print(a_set)
a_set.discard(5)
print(a_set)
'''
# </editor-fold>
# <editor-fold desc="数据结构的技巧">
# 数据结构的技巧-多重循环
# sorted 函数安装长短、大小、英文字母的顺序给每个列表中的元素进行排序。但并不会改变列表本身，只是用于展示：
'''
num_list = [6,2,7,4,1,3,5]
print(sorted(num_list))
print(num_list)
# reverse 参数是逆序整理：
print(sorted(num_list,reverse=True))
print(num_list)
'''
# 同时需要两个列表时：
'''
num = [1,2,3]
str = ['a','b','c']
for a,b in zip(num,str):
    print(b,'is',a)
'''
# 数据结构的技巧-推导式（List comprehension,或者叫列表的解析式）
'''
# 普通写法：
a = []
for i in range(1,11):
    a.append(i)
print(a)
# 列表解析式：执行效率更高
b = [i for i in range(1,11)]
print(b)
'''
# 格式：list = [item（想要放在列表中的元素） for item in iterable（for循环）]
# 列表推导式：
'''
a = [i**2 for i in range(1,10)]
print(a)
c = [j+1 for j in range(1,10)]
print(c)
k = [n for n in range(1,10) if n % 2 == 0]
print(k)
z = [letter.lower() for letter in 'ABCDEFGHIJKLMN']
print(z)
'''
# 字典推导式：必须满足键-值的两个条件
'''
# d = {i:j+1 for i in range(4)}
# print(d)
g = {i:j for i,j in zip(range(1,6),'abcde')}
print(g)
g = {i:j.upper() for i,j in zip(range(1,6),'abcde')}
print(g)
'''
# 数据结构的技巧-循环列表是获取元素的索引：enumerate
'''
letters = ['a','b','c','d','e','f','g']
for num,letter in enumerate(letters):
    print(letter,'is',num+1)
'''
# 数据结构的技巧-综合项目
# 瓦尔登湖的文本下载：https://pan.baidu.com/s/1o75GKZ4，下载后用PyCharm打开重新保存一次，避免编码问题。
# 用split方法将字符串中的每个单词分开，得到独立的单词：
'''
lyric = 'The night begin to shine,the night begin to shine'
words = lyric.split()
print(words)
'''
# 词频统计-count 方法统计重复出现到单词：
'''
path ='C:/Users/Administrator/Desktop/python/2.txt'
with open(path,'r') as text:
    words = text.read().split()
    print(words)
    for word in words:
        print('{}--{} times'.format(word,words.count(word)))
'''
'''
# Python标准库 — string模块，包含大量实用常量和类，以及一些过时的遗留功能，并还可用作字符串操作。
import string

patch = 'C:/Users/Administrator/Desktop/python/2.txt'

with open(patch,'r') as text:
# Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。
# 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。
# Python lower() 方法转换字符串中所有大写字符为小写。upper() 方法将字符串中的小写字母转为大写字母。
# split() 通过指定分隔符对字符串进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。
  # 语法：str.split(str="", num=string.count(str))
  # str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。
  # num -- 分割次数。默认为 -1, 即分隔所有。
    words = [raw_word.strip(string.punctuation).lower() for raw_word in text.read().split()]
# set 函数：转换成集合，自动去除其中所有重复的元素
    words_index = set(words)
# 创建一个以单词为键（key），出现频率为值（value）的字典：
    counts_dict = {index:words.count(index) for index in words_index}

# sorted()方法来对可迭代的序列排序生成新的序列。
    # key -- 主要是用来进行比较的元素，只有一个参数。用列表元素的某个属性或函数作为关键字，有默认值，迭代集合中的一项(指定可迭代对象中的一个元素来进行排序。)
    # reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
    # 返回值： 返回重新排序的列表。
# lambda 表达式：以字典中的值为排序的参数。
    for word in sorted(counts_dict,key=lambda x: counts_dict[x],reverse=True):
        print('{} -- {} times'.format(word,counts_dict[word]))

# string.punctuation：所有标点字符
    print(string.punctuation)
'''
# </editor-fold>

# <editor-fold desc="第七章 类与可口可乐">
# 第七章 类与可口可乐
# 用class定义一个类，类的变量称之为 类的属性（Class Atrribute）
'''
class CocaCola:
    formula = ['caffeine','sugar','water','soda']
# 类的实例化，被实例化后的对象称为 实例（instance）：
# 类属性的引用（attribute references），类的属性会被所有类的实例共享。
coke_for_me = CocaCola()
coke_for_you = CocaCola()

print(CocaCola.formula)
print(coke_for_me.formula)
print(coke_for_you.formula)

# 类的属性与正常的变量并无区别：
for element in coke_for_me.formula:
    print(element)

# 实例属性（Instance Atrribute）: 创建类后，通过 object.new_attr 的形式进行一个赋值，得到了一个新的实例变量，称为实例属性。
coke_for_China = CocaCola()
coke_for_China.local_logo = '可口可乐'
print(coke_for_China.local_logo)
'''
# 实例方法（Instance Method）:方法就是函数，方法是供实例使用的就称为实例方法。
'''
class CocaCola:
    formula = ['caffeine','sugar','water','soda']
    def drink(self):
        print('Energy!')

coke = CocaCola()
coke.drink()
'''
# self 参数其实就是被创建的实例本身：
# 函数的使用方法就是将一个个对象作为参数放入函数括号内。
'''
class CocaCola:
    formula = ['caffeine','sugar','water','soda']
    def drink(coke):
        print('Energy!')

coke = CocaCola()
coke.drink()

# 一旦一个类被实例化，其实可以使用跟函数相似的方式：
coke = CocaCola
coke.drink()  == CocaCola.drink(coke)   #左右两边的写法完全一致
'''
# 被实例化的对象会被编译器默默地传入后面方法的括号中，作为第一个参数。上面的两种方法是一样的，但更多是写成前面那种方式。
# 其实self这个参数名称是可以随意修改的，但按照Python的规矩，统一使用self.

# 更多参数
'''
class CocaCola:
    formula = ['caffeine','sugar','water','soda']
    def drink(self,how_much):
        if how_much == 'a sip':
            print('Cool~')
        elif how_much == 'whole bottle':
            print('Headache!')

ice_coke = CocaCola()
ice_coke.drink('a sip')
'''
# 魔术方法
# __init__()方法（注意“__"是两个下划线）
# init是initialize（初始化）的缩写，意味着在创建实例的时候不去引用 init()方法，其中的命令也会先被自动地执行。
'''
class CocaCola():
    formula = ['caffeine','sugar','water','soda']
    def __init__(self):
        self.local_logo = '可口可乐'

    def drink(self):
        print('Energy!')

coke = CocaCola()
print(coke.local_logo)
'''
'''
class CocaCola:
    formula = ['caffeine','sugar','water','soda']
    def __init__(self):

        for element in self.formula:
            print('Coke has {}!'.format(element))

    def drink(self):
        print('Energy!')

coke = CocaCola()
'''
# __init__() 可以有自己的参数，在实例化时往类后面的括号中放进参数，相应的所有参数都会传递到这个特殊的方法中。
'''
class CocaCola:
    formula = ['caffenine','sugar','water','soda']
    def __init__(self,logo_name):
        self.local_logo = logo_name

    def drink(self):
        print('Energy!')

coke = CocaCola('可口可乐')
coke.local_logo
'''
# self.local_logo = logo_name，左边是变量作为类的属性，右边是传入的这个参数作为变量，这个变量的赋值取决于初始化时所传入的参数，
# 如此处传入的值是“可口可乐”，那么“logo_name”参数就是“可口可乐”。

# 类的继承(Inheritance)
'''
class CocaCola:
    calories = 140
    sodium = 45
    total_carb = 39
    caffeine = 34
    ingredients = [
        'High Fructose Corn Syrup',
        'Carbonated Water',
        'Phosphoric Acid',
        'Natural Flavors',
        'Caramel Color',
        'Caffeine'
    ]
    def __init__(self,logo_name):
        self.local_logo = logo_name

    def drink(self):
        print('You got {} cal energy!'.format(self.calories))

# 创建新的类CaffeineFree，后面的口号放入CocaCola，表示这个类继承于CocaCola这个父类，CaffeineFree是之类。
# 类中的变量和方法可以完全被之类继承，但如需改动也可以进行覆盖（Override)。
class CaffeineFree(CocaCola):
    caffeine = 0
    ingredients = [
        'High Fructose Corn Syrup',
        'Carbonated Water',
        'Phosphoric Acid',
        'Natural Flavors',
        'Caramel Color',
    ]

coke_a = CaffeineFree('Cocacola-FREE')
coke_a.drink()
'''

# 令人困惑的类属性与实例属性
# Q1：类属性如果被重新赋值，是否会影响到类属性的引用？
'''
class TestA:
    attr = 1
obj_a = TestA()

TestA.attr = 42
print(obj_a.attr)
'''
# Q2: 实例属性如果被重新赋值，是否会影响到类属性的引用？
'''
class TestA:
    attr = 1
obj_a = TestA()
obj_b = TestA()

obj_a.attr = 42
print(obj_b.attr)
'''
# Q3: 类属性实例属性具有相同的名称，那么 . 后面引用的将会是什么？
'''
class TestA:
    attr = 1
    def __init__(self):
        self.attr = 42

obj_a = TestA()
print(obj_a.attr)
# __dict__ 是类的特殊属性，是一个字典，存储类或者实例的属性。存在于每一个类中，默认是隐藏的。
print(TestA.__dict__)
print(obj_a.__dict__)
'''
# Python中属性的引用机制是自外而内的，创建了实例后，开始引用属性时，编译器会先搜索该实例是否有该属性，有则引用；
# 没有则搜索所属的类是否有这个属性，有则引用，没有就只能报错了。

# 类的扩展理解
'''
obj1 = 1
obj2 = 'String!'
obj3 = []
obj4 = {}

print(type(obj1),type(obj2),type(obj3),type(obj4))
'''
# 如果安装了Beautifulsoup4第三方库，可以尝试如下这样。按住ctr点击Beautifulsoup查看一个soup对象的完整类定义。
'''
from bs4 import Beautifulsoup
soup = Beautifulsoup
print(type(soup))
'''

# 类的实践
# 其实类背后所承载的理念是OOP（面向对象）的编程理念。
# 制作填充用户假数据的小工具，设计思路：
# 父类：FakeUser，功能：1.随机姓名：a.单字名，b.双字名，c.有个名字就好了； 2.随机性别
# 子类：SnsUser，功能：1.随机数量的跟随者：a.few，b.a lot
# 先制作姓名词库的文件，一个姓氏，一个名，用open函数打开这两个文件，将其中的文字添加进列表中。
'''
ln_path = 'C:/Users/Administrator/Desktop/python/last_name.txt'
fn_path = 'C:/Users/Administrator/Desktop/python/first_name.txt'
fn = []
ln1 = []    #单字名
ln2 = []    #双字名
with open(fn_path,'r') as f:
    for line in f.readlines():
        fn.append(line.split('\n')[0]) # split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串
print(fn)

with open(ln_path,'r') as f:
    for line in f.readlines():
        if len(line.split('\n')[0]) == 1:
            ln1.append(line.split('\n')[0])
        else:
            ln2.append(line.split('\n')[0])
print(ln1)
print('='*70)   #分割线
print(ln2)
'''
# 1.将fn=[],ln1=[],ln2=[]修改成元组，元组比列表更省内存。
# 2.将打印结果复制粘贴到元组中，把这些变成常量。
"""
fn = ('赵', '钱', '孙', '李', '周', '吴', '郑', '王', '冯', '陈', '褚', '卫', '蒋', '沈', '韩', '杨', '', '朱', '秦', '尤', '许', '何', '吕', '施', '张', '孔', '曹', '严', '华', '金', '魏', '陶', '姜', '', '戚', '谢', '邹', '喻', '柏', '水', '窦', '章', '云', '苏', '潘', '葛', '奚', '范', '彭', '郎', '', '鲁', '韦', '昌', '马', '苗', '凤', '花', '方', '俞', '任', '袁', '柳', '酆', '鲍', '史', '唐', '费', '廉', '岑', '薛', '雷', '贺', '倪', '汤', '滕', '殷', '罗', '毕', '郝', '邬', '安', '常')
ln1 = ('晖', '鑫', '梁', '昆', '启', '俊', '成', '安', '皓', '致', '旭', '畅', '余', '石', '朋', '睿', '明', '英', '翰', '雄', '鸣', '盛', '嵘', '树', '以')
ln2 = ('思婉', '可荨', '渊晴', '悠悠', '雁盈', '莉之', '柏莺', '莉娜', '慧兰', '诗思', '然杉', '鑫曼', '心雪', '婉瑾', '碧淳', '悠巧', '嘉妙', '芬楠', '欣妍', '英萌', '洁琪', '清然', '学泽', '晴夏', '瑞韵')

# 现在开始定义父类FakeUser:
import random
'''
class FakeUser:
    def fake_name(self,one_word=False,two_words=False):
        if one_word:
            full_name = random.choice(fn) + random.choice(ln1)
        elif two_words:
            full_name = random.choice(fn) + random.choice(ln2)
        else:
            fulL_name = random.choice(fn) + random.choice(ln1 + ln2)
        print(full_name)
    def fake_gender(self):
        gender = random.choice(['男','女','未知'])
        print(gender)

# 接下来是定义子类：
class SnsUser(FakeUser):
    def get_followers(self,few=True,a_lot=False):
        if few:
            followers = random.randrange(1,10)
        elif a_lot:
            followers = random.randrange(10,50)
        print(followers)
user_a = FakeUser()
user_b= SnsUser()
user_a.fake_name()
user_b.get_followers(few=True)
'''
# 如果把上面的代码做一些调整，把所有的print替换成yield并在其上方加一层循环，就可以像range函数一样使用方法了：

class FakeUser():
    def fake_name(self,amount=1,one_word=False,two_words=False):
        n = 0
        while n <=amount:
            if one_word:
                full_name = random.choice(fn) + random.choice(ln1)
            elif two_words:
                full_name = random.choice(fn) + random.choice(ln2)
            else:
                full_name = random.choice(fn) + random.choice(ln1 + ln2)
            yield full_name
            n+=1
    def fake_gender(self,amount=1):
        n = 0
        while n <= amount:
            gender = random.choice(['男','女','未知'])
            yield gender
            n+=1
class SnsUser(FakeUser):
    def get_followers(self,amount=1,few=True,a_lot=False):
        n = 0
        while n <= amount:
            if few:
                followers = random.randrange(1,50)
            elif a_lot:
                followers = random.randrange(200,10000)
            yield followers
            n+=1
user_a = FakeUser()
user_b = SnsUser()
for name in user_a.fake_name(30):
    print(name)
for gender in user_a.fake_gender(30):
    print(gender)
"""
# 生成器（generator），在函数中只要在任意一种循环（loop）中使用yield返回结果，就可以得到类似于range函数的效果。
# 参考yield的用法详解：https://blog.csdn.net/mieleizhi0522/article/details/82142856/

# 安装自己的库
# 一般用pip进行第三方库的安装。也可以把自己的库提交到pip上，但还要添加一定量的代码和必要文件才行。
# 这里使用一个更简单的方法：
#   1.找到python安装目录，找到里面的site-packages文件夹；
#   2.记住你的文件名，它将作为引用时的名称，然后将你写的py文件放进去。
# 这个文件夹应该有你所装的所有第三方库。下面的命令可以查看安装路径：
'''
import sys
print(sys.path)
'''
# 打印出来的是一个列表，列表中的第四个是库安装路径所在，可以直接这么做：
'''
import sys
print(sys.path[3])
'''
# </editor-fold>
# <editor-fold desc="第八章 开始使用第三方库">
# 第八章 开始使用第三方库
# 如何根据自己的需求找到相应的库？
#   1.第三方库收录网站：https://awesome-python.com/
#   2.通过搜索引擎寻找（如Google，建议用英文搜索，能找到更多资源，如stackoverflow上的优质讨论）。
# 安装第三方库：
# 1.最简单的方式：在PyCharm安装
    # File - Settings - Python Interpreter - 点击“+” (点击“-”是删除库)- 选中库的名称 - 点击Install Package
# 2.最直接的方式：在终端/命令行安装
    # 安装pip：在cmd中输入 pip --version 检查是否已安装了pip，python3.4后安装好Python环境就可以直接支持pip
    # Python3安装库命令：pip3 install PackageNmae
    # 如果安装了python2和python3两个版本，肯能会遇到安装目录的问题，可换成：python3 -m pip install PackageName
# pip常用指令：
  # pip install --upgrade pip   #升级pip
  # pip uninstall flask         #卸载库
  # pip list                    #查看已安装库
# 安装某些库时，可能需要先安装依赖库，缺啥装啥。
# 最原始的方式：手动安装
  # 进入pypi.python.org 搜索需要安装的库：
    # 1.exe文件，下载跟电脑系统和Python环境对应的exe，一路点击next即可；
    # 2. .whl类文件，可以自动安装依赖包；
    # 3. 源码，大都是 zip、tar.zip、tar.bz2格式的压缩包，要求已经安装了依赖包。
    # .whl类文件安装：1) pip3 install wheel; 2) 进入下载路径,如：cd c:\download; 3) 安装：pip3 install xxx.whl
    # 源码压缩包安装：1）解压，解压文件夹中通常有一个 setup.py的文件，进入目录：cd C:\download；安装：python3 setup.py install;
    # 这个命令会把第三方库安装到系统python路径里，windows一般是在C:\Python3.5\Lib\site-packages
    # 想卸载库，找到Python路径，进入site-packages文件夹，删掉库文件即可。

# 使用第三方库
  # 在pycharm中输入库的名字，就会自动提示补全。输入后可能是灰色状态的（如import pandas)，因为还未在程序使用这个库，而不是库未安装（用前面提到的方式确认是否已安装库）
# </editor-fold>
